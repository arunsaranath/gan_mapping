# -*- coding: utf-8 -*-

"""
FileName:               micaAbundanceLib
Author Name:            Arun M Saranathan
Description:            This code file will be used to extract the abundance vectors corresponding the mica end-member
                        signatures as generated by Yuki's model

Date Created:           10th December 2019
Last Modified:          10th December 2019
"""

import numpy as np
import spectral.io.envi as envi
from spectral.io.envi import SpectralLibrary as sli
import os
from tqdm import tqdm
from scipy.io import loadmat
from scipy import interpolate
'Plotting tools'
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
'Get mica tools package'
from micaTools import micaTools
from generalUtilities import generalUtilities



def createMICA_abunVectors(micaBaseFolder = '/Volume2/arunFiles/MICA Library/mrocr_8001/data/',
                           imgLoc='/Volume1/data/CRISM/arun/sabcondv3/micaImages/'):
    """
    This function will look over the various MICA endmemebers and extract the abundance vectors corresponding to them

    :param micaBaseFolder: The folder where the MICA data has been stored
    :param imgLoc: The location where the MICA images and abundance vectors are stored
    :return:
    """
    'Create empty variables to hold the data'
    yukiEM_Abun = []
    endMem_name = []

    '----------------------------------------------------------------------------------------------------------------------'

    for r,d,f in os.walk(micaBaseFolder):
        for file in f:
            print(file)
            'Image files will have the end ".lbl"'
            if file.find('.lbl') != -1:
                lblFileName = os.path.join(r, file)
                lblInfo = micaTools().lblRead(lblFileName)

                imgName = lblInfo[0:116][19]
                imgName = imgName[1]
                imgName = imgName[1:12]

                numColumn = lblInfo[0:116][20]
                numColumn = numColumn[1]
                numColumn = int(numColumn[:-8])

                numRow = lblInfo[0:116][21]
                numRow = numRow[1]
                numRow = int(numRow[:-8])

                roiSize = lblInfo[0:116][28]
                roiSize = roiSize[1]
                xidx = roiSize.find('x')
                roiSize = int(roiSize[1:xidx])
                roiSize = (roiSize - 1) / 2

                imgFolder = os.path.join(imgLoc, imgName)

                if (os.path.isdir(imgFolder)):
                    for _, _, f1 in os.walk(imgFolder):
                        for file1 in f1:
                            if file1.find('_libAbun.img') != -1:
                                imgName = os.path.join(imgFolder, file1)
                                hdrName = imgName.replace('.img', '.hdr')

                                img = envi.open(hdrName, imgName)
                                cube = img.load()

                                roi = np.asarray(cube[(numRow - roiSize):(numRow + roiSize + 1),
                                                 (numColumn - roiSize):(numColumn + roiSize + 1),
                                                 :])
                                roi = roi.transpose(2, 0, 1).reshape(687, -1)

                                spectra = np.squeeze(np.mean(roi, 1))

                                endMem_name.append(lblInfo[30, 1][1:-1])
                                yukiEM_Abun.append(spectra)

    'Convert to numpy arrays'
    yukiEM_Abun = np.asarray(yukiEM_Abun)


    sliHdr = {'file type': "ENVI Spectral Library of Yuki's abundance for MICA endmembers",
                          'data type': str(4),
                          'interleave': "bsq",
                          'byte order': str(0),
                          'wavelength': np.arange(687),
                          #'lines': relabSpectra.shape[1],
                          #'samples': relabSpectra.shape[0],
                          #'bands': 1,
                          'spectra names': endMem_name,
                          'header offset': str(0),
                          'wavelength units': "Microns"}

    relabSli = sli(yukiEM_Abun, sliHdr, [])
    relabSli.save('/Volume2/arunFiles/python_HSITools/crismBalancingDatasets/dataProducts/micaEMAbundance')

def createCRISM_libraryYukiModel(yukiLibLoc='/Volume2/arunFiles/MATLAB_code/yukiCRISMProcessing/abundanceEst/libInfoA.mat',
                                 finalWvl=np.asarray([]), saveLib=True):
    """
    This function is used to convert the data from the MATLAB files Yuki has created to numpy arrays.

    :param yukiLibLoc: The location where the library is stored
    :return:
    """
    'Read the MAT file'
    libInfoA = loadmat(yukiLibLoc)
    libInfoA = libInfoA['infoA']

    if finalWvl.size == 0:
        finalWvl = np.arange(1020., 2620., 6.68)
        finalWvl = finalWvl /1000.
    else:
        finalWvl = np.asarray(finalWvl, dtype='f4')

    'Extract variables for wavelength and reflectance'
    wvl = libInfoA['wavelength']
    wvl = list(wvl[0])
    ref = libInfoA['reflectance']
    ref = list(ref[0])

    'Create a variable to hold '
    spectraLib = []

    try:
        for ii in tqdm(range(687)):
            'Get the wavelength and reflectance of the ith end-member'
            tempWvl = np.squeeze(np.array(wvl[ii], dtype='f4'))
            if tempWvl.max <0.1:
                tempWvl = tempWvl * 1000
            tempRef = np.squeeze(np.array(ref[ii], dtype='f4'))
            'Remove all nan values from both reflectance and wavelength'
            tempWvl = tempWvl[~np.isnan(tempRef)]
            tempRef = tempRef[~np.isnan(tempRef)]

            'find where the wavelength is 0'
            idxZero = np.where(tempRef == 0)[0]
            if idxZero.size != 0:
                tempWvl = np.delete(tempWvl, idxZero)
                tempRef = np.delete(tempRef, idxZero)


            if(ii == 647):
                print('here')

            #tempRef[np.isnan(tempRef)] = 0
            'Ensure that the unit is micrometers'
            if(tempWvl.min() > 100):
                tempWvl /= 1000.
            if(tempWvl[-1]<finalWvl[-1]):
                tempWvl[-1] = finalWvl[-1]
            'Interpolate to wavelength of interest'
            f1 = interpolate.interp1d(tempWvl, tempRef)
            finalSpectra = f1(finalWvl)

            spectraLib.append(finalSpectra)
    except ValueError:
        print('Encountered Value Error')
        return np.array([])

    if saveLib:
        np.save('/Volume2/arunFiles/python_HSITools/crismBalancingDatasets/dataProducts/spectraLib', spectraLib)
        np.save('/Volume2/arunFiles/python_HSITools/crismBalancingDatasets/dataProducts/wavelength', finalWvl)


    return spectraLib



if __name__ == "__main__":
    hdrLoc = '/Volume1/data/CRISM/arun/sabcondv3/micaImages/FRT00003E12/FRT00003E12_07_IF166L_TRR3_atcr_sabcondv3_1_Lib1112_1_4_5_l1_gadmm_a_v2_ca_nr.hdr'
    header = envi.read_envi_header(hdrLoc)
    wvl = np.asarray(header['wavelength'], dtype='f4')


    l1 = createCRISM_libraryYukiModel(finalWvl=wvl[4:244])


