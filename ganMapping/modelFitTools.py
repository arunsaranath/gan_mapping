# -*- coding: utf-8 -*-

"""
FileName:               modelFitTools
Author Name:            Arun M Saranathan
Description:            This code file contains functions needed to accomodate/manipulate data revcived from the
                        denosing models

Date Created:           03rd September 2019
Last Modified:          03rd September 2019
"""

'Import libraries needed'

'General Purpose python libraries'
import numpy as np
import os
from scipy import ndimage

'import spectral Python'
import spectral.io.envi as envi

'Import user defined libraries'
from generalUtilities import generalUtilities
from hsiUtilities import hsiUtilities

class modelFitTools():
    def __init__(self, strtBand=0, numBands=240, imgType='FRT'):
        self.strtBand = strtBand
        self.numBands = numBands
        self.stopBand = self.strtBand + self.numBands

        if(imgType == 'FRT') or (imgType == 'FRS') or (imgType == 'ATO'):
            self.strtRow = 0
            self.stopRow = 0
            self.strtCol = 29
            self.stopCol = -7
        else:
            if (imgType == 'HRL') or (imgType == 'HRS'):
                self.strtRow = 0
                self.stopRow = 0
                self.strtCol = 15
                self.stopCol = -4
            else:
                if (imgType == 'Unk'):
                    self.strtRow = 0
                    self.stopRow = 0
                    self.strtCol = 0
                    self.stopCol = 0

                else:
                    raise ValueError('Unknown CRISM data Type')

    '------------------------------------------------------------------------------------------------------------------'
    'Function to Smooth images spatially band by band using a boxcar/average filter'
    '------------------------------------------------------------------------------------------------------------------'

    def crismImgSmooth(self, imgName, filterSize=5):
        """
        This function smooths each band of the hyperspectral image band by band

        :param imgName: Name of the image to be smoothed
        :param filterSize: The kernel size of the boxcar(uniform) filter
        :return:
        """
        imgHdrName = imgName.replace('.img', '.hdr')
        header = envi.read_envi_header(imgHdrName)

        'Read in the background image'
        crImg = envi.open(imgHdrName, imgName)
        crCube = crImg.load()
        [rows, cols, bands] = crCube.shape

        'Initialize matrix to nans'
        crCube_smoothed = np.empty((rows, cols, bands), dtype=float)
        crCube_smoothed[:] = np.nan

        for ii in range(self.strtBand, self.stopBand, 1):
            bandImg = np.squeeze(crCube[self.strtRow:(rows + self.stopRow), self.strtCol:(cols + self.stopCol), ii])
            bandImg_smooth = ndimage.uniform_filter(bandImg, size=filterSize)
            crCube_smoothed[self.strtRow:(rows + self.stopRow),
            self.strtCol:(cols + self.stopCol), ii] = bandImg_smooth

        outFileName = imgName.replace('_CRnR', ('_smoothed' + str(filterSize) + '_CR'))
        outFileName = outFileName.replace('.img','.hdr')
        envi.save_image(outFileName, crCube_smoothed, dtype=np.float32, force=True,
                        interleave='bil', metadata=header)

        return outFileName.replace('.hdr', '.img')

    '------------------------------------------------------------------------------------------------------------------'
    'Function to generate the image containing the modeled spectra from Yukis model'
    '------------------------------------------------------------------------------------------------------------------'
    def crism_CreateModeledImage(self, abImgName, saveImg=0, targetFolder=''):
        """
        @function name      :crism_CreateModeledImage
        @description        :This function will be used to created modeled image from the constituents generated
                            using the UMass Pipeline
        ----------------------------------------------------------------------------------------------------------------
        INPUTS
        ----------------------------------------------------------------------------------------------------------------
        :param self:
        :param abImgName: Name/address of the absoprtion image generated by the UMass Pipeline
        :param saveImg: Flag to decide if the modeled image is to be saved. The image is saved if the flag is not 0.
                        (default = 0)
        ----------------------------------------------------------------------------------------------------------------
        OUTPUTS
        ----------------------------------------------------------------------------------------------------------------
        :return: msImg: The image modeled by the UMass pipeline
        """

        'The absorption image header is'
        abHdrName = abImgName.replace('.img', '.hdr')
        'Read in the background image'
        abImg = envi.open(abHdrName, abImgName)
        abCube = abImg.load()
        abHeader = envi.read_envi_header(abHdrName)

        'The background image name is'
        bgImgName = abImgName.replace('_AB', '_Bg')
        bgHdrName = bgImgName.replace('.img', '.hdr')
        bgImg = envi.open(bgHdrName, bgImgName)
        bgCube = bgImg.load()

        'The modeled image is'
        msCube = abCube * bgCube

        if (saveImg != 0):
            finalLoc = abImgName.rfind('/')
            imgName = abImgName[(finalLoc + 1):]
            imgName = imgName.replace('_AB', '_MS')
            imgName = imgName.replace('.img', '.hdr')
            if targetFolder:
                if not os.path.isdir(targetFolder):
                    os.makedirs(targetFolder)
                imgName = targetFolder + imgName
            else:
                localFolder = os.getcwd() + '/out'
                if not os.path.isdir(localFolder):
                    os.makedirs(localFolder)
                imgName = localFolder + imgName

            'Save the image'
            envi.save_image(imgName, msCube, dtype=np.float32, force=True,
                            interleave='bil', metadata=abHeader)
            return imgName.replace('.hdr', '.img')
        else:
            str = 'Completed'
            return str

    '------------------------------------------------------------------------------------------------------------------'
    'If a image has missing columns fill each row based on its neighbors'
    '------------------------------------------------------------------------------------------------------------------'
    def crism_fillNanRows(self, imgName):
        """
        This function fill the empty of NaN rows using the neighbors.

        :param imgName: Name/address of the image to be smoothed
        :return:
        """

        hdrName = imgName.replace('.img', '.hdr')
        header = envi.read_envi_header(hdrName)
        'Read in the background image'
        crImg = envi.open(hdrName, imgName)
        crCube = crImg.load()
        [rows, cols, bands] = crCube.shape

        arrCrImg = crCube.reshape((rows * cols, bands))
        arrCrImgCrop = arrCrImg[:, self.strtBand:self.stopBand]
        'Fill the NaNs in the columns'
        arrCrImgCrop = generalUtilities().fill_nan(arrCrImgCrop)
        'Fill the NaNs in the rows'
        arrCrImgCrop = generalUtilities().fill_nan(arrCrImgCrop.T)
        arrCrImg[:, self.strtBand:self.stopBand] = arrCrImgCrop.T
        'Reshape to image size'
        crCube_nr = arrCrImg.reshape((rows, cols, bands))

        'Save the background image'
        outFileName1 = imgName.replace('_CR', '_CRnR')
        outFileName1 = outFileName1.replace('.img', '.hdr')
        envi.save_image(outFileName1, crCube_nr, dtype='single',
                        force=True, interleave='bil', metadata=header)

        return outFileName1.replace('.hdr', '.img')